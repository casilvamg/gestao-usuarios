# Instruções do Copilot - Projeto Angular TypeScript

## Visão Geral do Projeto

Este é um projeto Angular TypeScript focado em gerenciamento de usuários (`gestao-usuarios`). Todo código deve seguir as melhores práticas do Angular e convenções de modo estrito do TypeScript.

---

## Estilo de Código e Padrões

### TypeScript

- **Modo Estrito**: Todos os arquivos devem compilar com `strict: true` em `tsconfig.json`
- **Segurança de Tipos**: Nunca use o tipo `any`. Use interfaces, tipos ou genéricos apropriados
- **Convenções de Nomenclatura**:
  - Classes: PascalCase (ex: `UserService`, `CreateUserComponent`)
  - Interfaces: PascalCase com prefixo `I` (ex: `IUser`, `IUserService`)
  - Tipos: PascalCase (ex: `UserType`, `UserStatus`)
  - Variáveis/Funções: camelCase (ex: `userName`, `getUserById()`)
  - Constantes: UPPER_SNAKE_CASE (ex: `MAX_USERS`, `API_TIMEOUT`)
  - Membros privados: camelCase com prefixo `_` (ex: `_userCache`)

### Melhores Práticas do Angular

- **Componentes**: Use o padrão Smart (Container) e Presentational (Dumb)
  - Componentes Container tratam lógica e estado (ex: `cadastro-usuario-container.component.ts`)
  - Componentes Presentational são reutilizáveis e focam em UI (ex: `cadastro-usuario.component.ts`)
- **Serviços**: Implemente `OnDestroy` quando necessário e desinscreva de Observables
- **RxJS**: Use o padrão `takeUntil()` para gerenciamento de inscrições em componentes
- **Detecção de Mudanças**: Use estratégia `OnPush` quando componentes não dependem de estado externo
- **Carregamento Lazy**: Módulos de rota devem ser carregados via `loadChildren` na configuração de roteamento

### Organização de Arquivos

```
modulo/
├── models/
│   └── *.model.ts         (interfaces e tipos)
├── services/
│   └── *.service.ts       (lógica de negócio e chamadas de API)
├── pages/
│   └── feature/
│       ├── *-container.component.ts    (componente container)
│       ├── *.component.ts              (componente presentational)
│       ├── *.component.html
│       ├── *.component.scss
│       └── *.component.spec.ts
└── *.module.ts
```

---

## Diretrizes de Codificação

### Estrutura de Componente

```typescript
import {
  Component,
  Input,
  Output,
  EventEmitter,
  OnInit,
  OnDestroy,
} from "@angular/core";
import { Subject } from "rxjs";
import { takeUntil } from "rxjs/operators";

@Component({
  selector: "app-feature-name",
  templateUrl: "./feature-name.component.html",
  styleUrls: ["./feature-name.component.scss"],
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class FeatureNameComponent implements OnInit, OnDestroy {
  @Input() data: any;
  @Output() action = new EventEmitter<void>();

  private destroy$ = new Subject<void>();

  constructor(private service: YourService) {}

  ngOnInit(): void {
    // Lógica de inicialização
  }

  ngOnDestroy(): void {
    this.destroy$.next();
    this.destroy$.complete();
  }
}
```

### Estrutura de Serviço

```typescript
import { Injectable } from "@angular/core";
import { HttpClient } from "@angular/common/http";
import { Observable, BehaviorSubject } from "rxjs";

@Injectable({
  providedIn: "root",
})
export class YourService {
  private readonly API_BASE_URL = "/api/endpoint";
  private dataSubject$ = new BehaviorSubject<any>(null);

  constructor(private http: HttpClient) {}

  getData(): Observable<any> {
    return this.http.get<any>(this.API_BASE_URL);
  }
}
```

### Tratamento de Erros

- Sempre trate erros em chamadas HTTP com mensagens apropriadas
- Use o operador RxJS `catchError` para tratamento de erros
- Registre erros com níveis de severidade apropriados
- Forneça mensagens de erro amigáveis ao usuário na UI

### Testes

- Testes unitários necessários para serviços e componentes complexos
- Use `TestBed` para testes de componentes
- Simule (mock) serviços e chamadas HTTP
- Objetivo de pelo menos 80% de cobertura de código para funcionalidade crítica
- Nomenclatura de arquivo de teste: `*.spec.ts`

---

## Fluxo de Trabalho Git

### Mensagens de Commit

Siga o formato de commits convencionais:

```
type(scope): subject

body (opcional)

footer (opcional)
```

**Tipos**: `feat`, `fix`, `docs`, `style`, `refactor`, `perf`, `test`, `chore`

**Exemplos**:

- `feat(usuario): add user creation form`
- `fix(usuario-service): handle null user data`
- `refactor(listar-usuario): optimize list rendering`
- `docs(readme): update installation instructions`

### Estratégia de Branch

- `main`: Código pronto para produção
- `develop`: Branch de integração para features
- `feature/description`: Novas funcionalidades
- `fix/description`: Correções de bugs
- `docs/description`: Atualizações de documentação

---

## Considerações de Desempenho

- **Detecção de Mudanças**: Use estratégia `OnPush` para melhor desempenho
- **Renderização de Lista**: Use função `trackBy` com `*ngFor` para listas grandes
- **Tamanho do Bundle**: Carregue módulos e componentes com lazy-loading quando possível
- **Vazamento de Memória**: Sempre desinscreva de Observables usando padrão `takeUntil`
- **Cache HTTP**: Implemente estratégias de cache para chamadas de API repetidas

---

## Documentação

- **Comentários**: Use comentários JSDoc para métodos públicos e lógica complexa
- **README**: Mantenha atualizado com instruções de configuração, build e deploy
- **Comentários Inline**: Explique "por quê", não "o quê" - o código deve ser autoexplicativo
- **APIs Descontinuadas**: Marque com comentário `@deprecated` e forneça alternativas

---

## Build & Deploy

### Desenvolvimento

```bash
npm install
npm start
```

### Build para Produção

```bash
npm run build
```

### Testes

```bash
npm test
```

### Configuração de Ambiente

- Use `environment.ts` para desenvolvimento
- Use `environment.prod.ts` para produção
- Gerencie endpoints de API através de arquivos de ambiente

---

## Tarefas Comuns

### Adicionando uma Nova Feature

1. Crie branch de feature a partir de `develop`
2. Crie nova estrutura de módulo em `modules/`
3. Gere componentes com Angular CLI: `ng generate component`
4. Crie serviço com interfaces em `models/`
5. Implemente rota com carregamento lazy
6. Escreva testes unitários
7. Crie pull request para revisão

### Corrigindo um Bug

1. Crie branch de fix a partir de `main` ou `develop`
2. Identifique a causa raiz
3. Escreva teste falhando (se aplicável)
4. Corrija o problema
5. Verifique o fix com testes existentes
6. Crie pull request com descrição

### Atualizando Dependências

```bash
npm update
npm audit fix
```

---

## Dicas de Debug

- Use extensão Angular DevTools do navegador
- Ative source maps em modo dev
- Use `console.log()` com prefixos descritivos
- Aproveite DevTools do navegador para análise de rede e desempenho
- Use `ng serve --poll` se detecção de mudanças de arquivo não funcionar

---

## Recursos

- [Documentação Oficial do Angular](https://angular.io/docs)
- [Manual do TypeScript](https://www.typescriptlang.org/docs/)
- [Documentação do RxJS](https://rxjs.dev/)
- [Guia de Estilo do Angular](https://angular.io/guide/styleguide)

---

## Contato & Dúvidas

Para dúvidas ou esclarecimentos sobre estas diretrizes, consulte a documentação do projeto ou o líder do time.

Atualizado em: Fevereiro de 2026
